#!/bin/bash
## This script is used to get pairwise and average Fst estimates from angsd for each population / group pair from every SNP in .saf
## downloaded from Nina github 10/14/19, modified by mph for window Fst (add windowing; newest angsd version; -whichFst)
## does this script assume .saf files are unfolded site freq spectra?
## yes: from doc, use UNFOLDED .saf.idx files generated by -doSaf.
## -whichFst 1 for small sample sizes - change at realSFS fst index command for larger sample sizes
## windowing doc: -type 0 Split out the genome into blocks. And use the first window that have data for the entire window. Then we will have the same windowcenters across datasets.
## usage: ./get_fst_windows.sh /workdir/mph75/angsd/minMaf05 /workdir/mph75/3pops_names.txt 1 _minI13_D20maxD60_minQ20_minMAF05_SNPe6_no56inv

module load angsd/0.931

SAFDIR=$1 #  Path to per population saf.gz files. An example for October 2019 NYC_WGS is /workdir/mph75/angsd/minMaf05
SAMPLETABLE=$2 # Path to a sample table where the 1st column is the prefix of the raw fastq files. The 4th column is the sample ID, the 2nd column is the lane number, and the 3rd column is sequence ID. The combination of these three columns have to be unique. The 6th column should be data type, which is either pe or se. An example of such a sample table is: /workdir/cod/greenland-cod/sample_lists/sample_table.tsv
#mph simplifying this to single column of population names, /workdir/mph75/3pops_names.txt
POPCOLUMN=$3 # The column index of the variable that you want to group by in the sample table above. In the Greenland project, it's the fifth column, and thus 5
#for mph file 3pop_names.txt, POPCOLUMN=1
BASENAME=$4 # Base name of the saf files excluding $POP and exlcuding ".saf.gz". It will be used as the base name of all output files. An example from Oct 2019 NYC_WGS is _minI13_D20maxD200_minQ20_minMAF05_SNPe6

cd $SAFDIR

I=1
for POP1 in `tail -n +2 $SAMPLETABLE | cut -f $POPCOLUMN | sort | uniq`; do 
	J=1
	for POP2 in `tail -n +2 $SAMPLETABLE | cut -f $POPCOLUMN | sort | uniq`; do 
		if [ $I -lt $J ]; then
			echo $POP1'_'$POP2
			# Check if Fst output already exists
			if [ ! -f $POP1'_'$POP2$BASENAME'_fold.fst' ]; then
				# Generate the 2dSFS to be used as a prior for Fst estimation (and individual plots)				
				/tools/angsd-0.931/misc/realSFS $POP1$BASENAME'.saf.idx' $POP2$BASENAME'.saf.idx' -fold 1 > $POP1'_'$POP2$BASENAME'_fold.2dSFS'
				# Estimating Fst in angsd
				/tools/angsd-0.931/misc/realSFS fst index  $POP1$BASENAME'.saf.idx' $POP2$BASENAME'.saf.idx' -sfs $POP1'_'$POP2$BASENAME'_fold.2dSFS' -fold 1  -whichFst 1 -fstout $POP1'_'$POP2$BASENAME'_fold.alpha_beta' #whichFst 1 for small sample sizes, newer version of angsd
				/tools/angsd-0.931/misc/realSFS fst print $POP1'_'$POP2$BASENAME'_fold.alpha_beta.fst.idx' > $POP1'_'$POP2$BASENAME'_fold.alpha_beta.txt'
				awk '{ print $0 "\t" $3 / $4 }' $POP1'_'$POP2$BASENAME'_fold.alpha_beta.txt' > $POP1'_'$POP2$BASENAME'_fold.fst'
			fi
			# Check if average Fst output already exists
			if [ ! -f $POP1'_'$POP2$BASENAME'_fold.average_fst.txt' ]; then
				# Estimating average Fst in angsd
				/tools/angsd-0.931/misc/realSFS fst stats $POP1'_'$POP2$BASENAME'_fold.alpha_beta.fst.idx' > $POP1'_'$POP2$BASENAME'_fold.average_fst.txt' 
				# Generate windowed Fst, 1, 5 and 15 kb windows non-overlappin
				/tools/angsd-0.931/misc/realSFS fst stats2 $POP1'_'$POP2$BASENAME'_fold.alpha_beta.fst.idx' -type 0 -win 100 -step 100 > $POP1'_'$POP2$BASENAME'_fold.100_win_100_fst.txt'
				/tools/angsd-0.931/misc/realSFS fst stats2 $POP1'_'$POP2$BASENAME'_fold.alpha_beta.fst.idx' -type 0 -win 500 -step 500 > $POP1'_'$POP2$BASENAME'_fold.500_win_500_fst.txt'
                		/tools/angsd-0.931/misc/realSFS fst stats2 $POP1'_'$POP2$BASENAME'_fold.alpha_beta.fst.idx' -type 0 -win 1000 -step 1000 > $POP1'_'$POP2$BASENAME'_fold.1kb_win_1kb_fst.txt'
				/tools/angsd-0.931/misc/realSFS fst stats2 $POP1'_'$POP2$BASENAME'_fold.alpha_beta.fst.idx' -type 0 -win 15000 -step 15000 > $POP1'_'$POP2$BASENAME'_fold.15kb_win_15kb_fst.txt' 
			fi
		fi
		J=$((J+1))
	done
	I=$((I+1))
done
